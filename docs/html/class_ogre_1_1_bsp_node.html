<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tadPole: Ogre::BspNode Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tadPole
   </div>
   <div id="projectbrief">A simple game engine to create simple games.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_ogre_1_1_bsp_node.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_ogre_1_1_bsp_node-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Ogre::BspNode Class Reference<div class="ingroups"><a class="el" href="group___plugins.html">Plugins</a> &raquo; <a class="el" href="group___b_s_p_scene_manager.html">BSPSceneManager</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_ogre_bsp_node_8h_source.html">OgreBspNode.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Ogre::BspNode:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_ogre_1_1_bsp_node.png" usemap="#Ogre::BspNode_map" alt=""/>
  <map id="Ogre::BspNode_map" name="Ogre::BspNode_map">
<area href="class_ogre_1_1_allocated_object.html" alt="Ogre::AllocatedObject&lt; Alloc &gt;" shape="rect" coords="0,0,276,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ogre_1_1_bsp_node_1_1_brush.html">Brush</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af86ad5b76b6e2327db0e702d4216ad30"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struct_ogre_1_1set.html">set</a>&lt; const <a class="el" href="class_ogre_1_1_movable_object.html">MovableObject</a> * &gt;::<a class="el" href="glext_8h.html#ad5ddf6fca7b585646515660e810e0188">type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_node.html#af86ad5b76b6e2327db0e702d4216ad30">IntersectingObjectSet</a></td></tr>
<tr class="separator:af86ad5b76b6e2327db0e702d4216ad30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade6cf2f9bdd72538d3b2863bfb598f98"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struct_ogre_1_1vector.html">vector</a>&lt; <a class="el" href="struct_ogre_1_1_bsp_node_1_1_brush.html">Brush</a> * &gt;::<a class="el" href="glext_8h.html#ad5ddf6fca7b585646515660e810e0188">type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_node.html#ade6cf2f9bdd72538d3b2863bfb598f98">NodeBrushList</a></td></tr>
<tr class="separator:ade6cf2f9bdd72538d3b2863bfb598f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a39b74504f7252462d27f69bbeef5dc99"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_node.html#a39b74504f7252462d27f69bbeef5dc99">BspNode</a> (<a class="el" href="class_ogre_1_1_bsp_level.html">BspLevel</a> *owner, bool <a class="el" href="class_ogre_1_1_bsp_node.html#aaeb2ac6a36ce7bbfb351f272ff724cf8">isLeaf</a>)</td></tr>
<tr class="separator:a39b74504f7252462d27f69bbeef5dc99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10395588ed29a1d34e3b028643dd2d77"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_node.html#a10395588ed29a1d34e3b028643dd2d77">BspNode</a> ()</td></tr>
<tr class="separator:a10395588ed29a1d34e3b028643dd2d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74871a4318ee6f0bfdf068a988bc2496"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_node.html#a74871a4318ee6f0bfdf068a988bc2496">~BspNode</a> ()</td></tr>
<tr class="separator:a74871a4318ee6f0bfdf068a988bc2496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb2ac6a36ce7bbfb351f272ff724cf8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_node.html#aaeb2ac6a36ce7bbfb351f272ff724cf8">isLeaf</a> (<a class="el" href="_s_d_l__opengles2__gl2ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>) const</td></tr>
<tr class="separator:aaeb2ac6a36ce7bbfb351f272ff724cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae79ffff46af0c8df473e4cf16e4f3a43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_bsp_node.html">BspNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_node.html#ae79ffff46af0c8df473e4cf16e4f3a43">getFront</a> (<a class="el" href="_s_d_l__opengles2__gl2ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>) const</td></tr>
<tr class="separator:ae79ffff46af0c8df473e4cf16e4f3a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a943797f8b1e7d04f7593c3e732972460"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_bsp_node.html">BspNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_node.html#a943797f8b1e7d04f7593c3e732972460">getBack</a> (<a class="el" href="_s_d_l__opengles2__gl2ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>) const</td></tr>
<tr class="separator:a943797f8b1e7d04f7593c3e732972460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4dd978cc8a7a6bcd35921d9ee37c5c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_plane.html#aa5d44b14d6f032f3e0a26e83589180bc">Plane::Side</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_node.html#ae4dd978cc8a7a6bcd35921d9ee37c5c7">getSide</a> (const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;point) const</td></tr>
<tr class="separator:ae4dd978cc8a7a6bcd35921d9ee37c5c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c549e6cac556e398aaccd83a9ace52c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_bsp_node.html">BspNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_node.html#a9c549e6cac556e398aaccd83a9ace52c">getNextNode</a> (const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;point) const</td></tr>
<tr class="separator:a9c549e6cac556e398aaccd83a9ace52c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf82d30b03b4819d3f4cd161ca53f3bf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_plane.html">Plane</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_node.html#aaf82d30b03b4819d3f4cd161ca53f3bf">getSplitPlane</a> (<a class="el" href="_s_d_l__opengles2__gl2ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>) const</td></tr>
<tr class="separator:aaf82d30b03b4819d3f4cd161ca53f3bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d9e0048384c0a8895a79d75bfc8ec2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_axis_aligned_box.html">AxisAlignedBox</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_node.html#a29d9e0048384c0a8895a79d75bfc8ec2">getBoundingBox</a> (<a class="el" href="_s_d_l__opengles2__gl2ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>) const</td></tr>
<tr class="separator:a29d9e0048384c0a8895a79d75bfc8ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf0f3cd4f006d876302502182569ecee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_node.html#aaf0f3cd4f006d876302502182569ecee">getNumFaceGroups</a> (<a class="el" href="_s_d_l__opengles2__gl2ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>) const</td></tr>
<tr class="separator:aaf0f3cd4f006d876302502182569ecee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec9a1bc496cd833f81869079741a122b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_node.html#aec9a1bc496cd833f81869079741a122b">getFaceGroupStart</a> (<a class="el" href="_s_d_l__opengles2__gl2ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>) const</td></tr>
<tr class="separator:aec9a1bc496cd833f81869079741a122b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89db45619ae315c31cd3880aad56b94c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_node.html#a89db45619ae315c31cd3880aad56b94c">isLeafVisible</a> (const <a class="el" href="class_ogre_1_1_bsp_node.html">BspNode</a> *leaf) const</td></tr>
<tr class="separator:a89db45619ae315c31cd3880aad56b94c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5702538be4c791af37cd73d2aa353a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_s_d_l__opengles2__gl2ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_node.html#ac5702538be4c791af37cd73d2aa353a5">_addMovable</a> (const <a class="el" href="class_ogre_1_1_movable_object.html">MovableObject</a> *mov)</td></tr>
<tr class="memdesc:ac5702538be4c791af37cd73d2aa353a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method for telling the node that a movable intersects it.  <a href="#ac5702538be4c791af37cd73d2aa353a5">More...</a><br /></td></tr>
<tr class="separator:ac5702538be4c791af37cd73d2aa353a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa10efd90b923c891eba69bad3b06d450"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_s_d_l__opengles2__gl2ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_node.html#aa10efd90b923c891eba69bad3b06d450">_removeMovable</a> (const <a class="el" href="class_ogre_1_1_movable_object.html">MovableObject</a> *mov)</td></tr>
<tr class="memdesc:aa10efd90b923c891eba69bad3b06d450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method for telling the node that a movable no longer intersects it.  <a href="#aa10efd90b923c891eba69bad3b06d450">More...</a><br /></td></tr>
<tr class="separator:aa10efd90b923c891eba69bad3b06d450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb496664856e47c5ac433dce45ec83f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_node.html#adb496664856e47c5ac433dce45ec83f8">getDistance</a> (const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;pos) const</td></tr>
<tr class="memdesc:adb496664856e47c5ac433dce45ec83f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the signed distance to the dividing plane.  <a href="#adb496664856e47c5ac433dce45ec83f8">More...</a><br /></td></tr>
<tr class="separator:adb496664856e47c5ac433dce45ec83f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac31674d044317b6e900efe52acb0439f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_bsp_node.html#ade6cf2f9bdd72538d3b2863bfb598f98">NodeBrushList</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_node.html#ac31674d044317b6e900efe52acb0439f">getSolidBrushes</a> (<a class="el" href="_s_d_l__opengles2__gl2ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>) const</td></tr>
<tr class="memdesc:ac31674d044317b6e900efe52acb0439f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main brush memory held on level.  <a href="#ac31674d044317b6e900efe52acb0439f">More...</a><br /></td></tr>
<tr class="separator:ac31674d044317b6e900efe52acb0439f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab13aab15a8670d2aac451da8b97251cc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_bsp_node.html#af86ad5b76b6e2327db0e702d4216ad30">IntersectingObjectSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_node.html#ab13aab15a8670d2aac451da8b97251cc">getObjects</a> (<a class="el" href="_s_d_l__opengles2__gl2ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>) const</td></tr>
<tr class="separator:ab13aab15a8670d2aac451da8b97251cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a9736c757eeb9cd899c511b9de8b43d37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_bsp_level.html">BspLevel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_node.html#a9736c757eeb9cd899c511b9de8b43d37">mOwner</a></td></tr>
<tr class="separator:a9736c757eeb9cd899c511b9de8b43d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe0862d80295c90d94246abb2b951a91"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_node.html#abe0862d80295c90d94246abb2b951a91">mIsLeaf</a></td></tr>
<tr class="memdesc:abe0862d80295c90d94246abb2b951a91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Back-reference to containing level.  <a href="#abe0862d80295c90d94246abb2b951a91">More...</a><br /></td></tr>
<tr class="separator:abe0862d80295c90d94246abb2b951a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce6facb22a7c2363f48d9283de78632"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_plane.html">Plane</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_node.html#acce6facb22a7c2363f48d9283de78632">mSplitPlane</a></td></tr>
<tr class="separator:acce6facb22a7c2363f48d9283de78632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8e71ff943c560f8603242f47db40478"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_bsp_node.html">BspNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_node.html#ae8e71ff943c560f8603242f47db40478">mFront</a></td></tr>
<tr class="separator:ae8e71ff943c560f8603242f47db40478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeaabf9f30966c28d7131a4e4d0f496b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_bsp_node.html">BspNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_node.html#aaeaabf9f30966c28d7131a4e4d0f496b">mBack</a></td></tr>
<tr class="separator:aaeaabf9f30966c28d7131a4e4d0f496b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad69a374aa92008df8d65b33eb30c207d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_node.html#ad69a374aa92008df8d65b33eb30c207d">mVisCluster</a></td></tr>
<tr class="separator:ad69a374aa92008df8d65b33eb30c207d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a2fd9dac5864edd6169b3e9d188dda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_axis_aligned_box.html">AxisAlignedBox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_node.html#a36a2fd9dac5864edd6169b3e9d188dda">mBounds</a></td></tr>
<tr class="separator:a36a2fd9dac5864edd6169b3e9d188dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a844b03dd60cac3277bcd2f2c262bae18"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_node.html#a844b03dd60cac3277bcd2f2c262bae18">mNumFaceGroups</a></td></tr>
<tr class="separator:a844b03dd60cac3277bcd2f2c262bae18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8268f4997a3e9d91fcd2a1f8aeee3b9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_node.html#ac8268f4997a3e9d91fcd2a1f8aeee3b9">mFaceGroupStart</a></td></tr>
<tr class="separator:ac8268f4997a3e9d91fcd2a1f8aeee3b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b0966df9e5b094abc9bcab656c9c6bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_bsp_node.html#af86ad5b76b6e2327db0e702d4216ad30">IntersectingObjectSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_node.html#a9b0966df9e5b094abc9bcab656c9c6bd">mMovables</a></td></tr>
<tr class="separator:a9b0966df9e5b094abc9bcab656c9c6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff118c3b93e2ced54e9345d96e87d384"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_bsp_node.html#ade6cf2f9bdd72538d3b2863bfb598f98">NodeBrushList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_node.html#aff118c3b93e2ced54e9345d96e87d384">mSolidBrushes</a></td></tr>
<tr class="separator:aff118c3b93e2ced54e9345d96e87d384"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a8c663a45872e4b89850c3ba482beaef5"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_node.html#a8c663a45872e4b89850c3ba482beaef5">BspLevel</a></td></tr>
<tr class="separator:a8c663a45872e4b89850c3ba482beaef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1092a75e646a2cecdd62b54da97a09bc"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_node.html#a1092a75e646a2cecdd62b54da97a09bc">operator&lt;&lt;</a> (std::ostream &amp;o, <a class="el" href="class_ogre_1_1_bsp_node.html">BspNode</a> &amp;<a class="el" href="glext_8h.html#ae2b4646468bc89d0ba646f5cf838e051">n</a>)</td></tr>
<tr class="separator:a1092a75e646a2cecdd62b54da97a09bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Encapsulates a node in a BSP tree. A BSP tree represents space partitioned by planes . The space which is partitioned is either the world (in the case of the root node) or the space derived from their parent node. Each node can have elements which are in front or behind it, which are it's children and these elements can either be further subdivided by planes, or they can be undivided spaces or 'leaf nodes' - these are the nodes which actually contain objects and world geometry.The leaves of the tree are the stopping point of any tree walking algorithm, both for rendering and collision detection etc. <a class="el" href="namespace_ogre.html">Ogre</a> chooses not to represent splitting nodes and leaves as separate structures, but to merge the two for simplicity of the walking algorithm. If a node is a leaf, the <a class="el" href="class_ogre_1_1_bsp_node.html#aaeb2ac6a36ce7bbfb351f272ff724cf8">isLeaf()</a> method returns true and both <a class="el" href="class_ogre_1_1_bsp_node.html#ae79ffff46af0c8df473e4cf16e4f3a43">getFront()</a> and <a class="el" href="class_ogre_1_1_bsp_node.html#a943797f8b1e7d04f7593c3e732972460">getBack()</a> return null pointers. If the node is a partitioning plane <a class="el" href="class_ogre_1_1_bsp_node.html#aaeb2ac6a36ce7bbfb351f272ff724cf8">isLeaf()</a> returns false and <a class="el" href="class_ogre_1_1_bsp_node.html#ae79ffff46af0c8df473e4cf16e4f3a43">getFront()</a> and <a class="el" href="class_ogre_1_1_bsp_node.html#a943797f8b1e7d04f7593c3e732972460">getBack()</a> will return the corresponding <a class="el" href="class_ogre_1_1_bsp_node.html">BspNode</a> objects. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="af86ad5b76b6e2327db0e702d4216ad30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af86ad5b76b6e2327db0e702d4216ad30">&#9670;&nbsp;</a></span>IntersectingObjectSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct_ogre_1_1set.html">set</a>&lt;const <a class="el" href="class_ogre_1_1_movable_object.html">MovableObject</a>*&gt;::<a class="el" href="glext_8h.html#ad5ddf6fca7b585646515660e810e0188">type</a> <a class="el" href="class_ogre_1_1_bsp_node.html#af86ad5b76b6e2327db0e702d4216ad30">Ogre::BspNode::IntersectingObjectSet</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ade6cf2f9bdd72538d3b2863bfb598f98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade6cf2f9bdd72538d3b2863bfb598f98">&#9670;&nbsp;</a></span>NodeBrushList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct_ogre_1_1vector.html">vector</a>&lt;<a class="el" href="struct_ogre_1_1_bsp_node_1_1_brush.html">Brush</a>*&gt;::<a class="el" href="glext_8h.html#ad5ddf6fca7b585646515660e810e0188">type</a> <a class="el" href="class_ogre_1_1_bsp_node.html#ade6cf2f9bdd72538d3b2863bfb598f98">Ogre::BspNode::NodeBrushList</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a39b74504f7252462d27f69bbeef5dc99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39b74504f7252462d27f69bbeef5dc99">&#9670;&nbsp;</a></span>BspNode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::BspNode::BspNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_bsp_level.html">BspLevel</a> *&#160;</td>
          <td class="paramname"><em>owner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isLeaf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor, only to be used by <a class="el" href="class_ogre_1_1_bsp_level.html">BspLevel</a>. </p>

</div>
</div>
<a id="a10395588ed29a1d34e3b028643dd2d77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10395588ed29a1d34e3b028643dd2d77">&#9670;&nbsp;</a></span>BspNode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::BspNode::BspNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a74871a4318ee6f0bfdf068a988bc2496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74871a4318ee6f0bfdf068a988bc2496">&#9670;&nbsp;</a></span>~BspNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::BspNode::~BspNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac5702538be4c791af37cd73d2aa353a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5702538be4c791af37cd73d2aa353a5">&#9670;&nbsp;</a></span>_addMovable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_s_d_l__opengles2__gl2ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a> Ogre::BspNode::_addMovable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_movable_object.html">MovableObject</a> *&#160;</td>
          <td class="paramname"><em>mov</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal method for telling the node that a movable intersects it. </p>

</div>
</div>
<a id="aa10efd90b923c891eba69bad3b06d450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa10efd90b923c891eba69bad3b06d450">&#9670;&nbsp;</a></span>_removeMovable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_s_d_l__opengles2__gl2ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a> Ogre::BspNode::_removeMovable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_movable_object.html">MovableObject</a> *&#160;</td>
          <td class="paramname"><em>mov</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal method for telling the node that a movable no longer intersects it. </p>

</div>
</div>
<a id="a943797f8b1e7d04f7593c3e732972460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a943797f8b1e7d04f7593c3e732972460">&#9670;&nbsp;</a></span>getBack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_bsp_node.html">BspNode</a>* Ogre::BspNode::getBack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_s_d_l__opengles2__gl2ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to a <a class="el" href="class_ogre_1_1_bsp_node.html">BspNode</a> containing the subspace on the negative side of the splitting plane. This method should only be called on a splitting node, i.e. where <a class="el" href="class_ogre_1_1_bsp_node.html#aaeb2ac6a36ce7bbfb351f272ff724cf8">isLeaf()</a> returns false. Calling this method on a leaf node will throw an exception. </p>

</div>
</div>
<a id="a29d9e0048384c0a8895a79d75bfc8ec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29d9e0048384c0a8895a79d75bfc8ec2">&#9670;&nbsp;</a></span>getBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_axis_aligned_box.html">AxisAlignedBox</a>&amp; Ogre::BspNode::getBoundingBox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_s_d_l__opengles2__gl2ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the axis-aligned box which contains this node if it is a leaf. This method should only be called on a leaf node. It returns a box which can be used in calls like <a class="el" href="class_ogre_1_1_camera.html#a71fff8dac8cbf9bd3911e49a484fa61c">Camera::isVisible</a> to determine if the leaf node is visible in the view. </p>

</div>
</div>
<a id="adb496664856e47c5ac433dce45ec83f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb496664856e47c5ac433dce45ec83f8">&#9670;&nbsp;</a></span>getDistance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> Ogre::BspNode::getDistance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the signed distance to the dividing plane. </p>

</div>
</div>
<a id="aec9a1bc496cd833f81869079741a122b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec9a1bc496cd833f81869079741a122b">&#9670;&nbsp;</a></span>getFaceGroupStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Ogre::BspNode::getFaceGroupStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_s_d_l__opengles2__gl2ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the index to the face group index list for this leaf node. The contents of this buffer is a list of indexes which point to the actual face groups held in a central buffer in the <a class="el" href="class_ogre_1_1_bsp_level.html">BspLevel</a> class (in actual fact for efficiency the indexes themselves are also held in a single buffer in <a class="el" href="class_ogre_1_1_bsp_level.html">BspLevel</a> too). The reason for this indirection is that the buffer of indexes to face groups is organised in chunks relative to nodes, whilst the main buffer of face groups may not be. Should only be called on a leaf node. </p>

</div>
</div>
<a id="ae79ffff46af0c8df473e4cf16e4f3a43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae79ffff46af0c8df473e4cf16e4f3a43">&#9670;&nbsp;</a></span>getFront()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_bsp_node.html">BspNode</a>* Ogre::BspNode::getFront </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_s_d_l__opengles2__gl2ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to a <a class="el" href="class_ogre_1_1_bsp_node.html">BspNode</a> containing the subspace on the positive side of the splitting plane. This method should only be called on a splitting node, i.e. where <a class="el" href="class_ogre_1_1_bsp_node.html#aaeb2ac6a36ce7bbfb351f272ff724cf8">isLeaf()</a> returns false. Calling this method on a leaf node will throw an exception. </p>

</div>
</div>
<a id="a9c549e6cac556e398aaccd83a9ace52c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c549e6cac556e398aaccd83a9ace52c">&#9670;&nbsp;</a></span>getNextNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_bsp_node.html">BspNode</a>* Ogre::BspNode::getNextNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the next node down in the tree, with the intention of locating the leaf containing the given point. This method should only be called on a splitting node, i.e. where <a class="el" href="class_ogre_1_1_bsp_node.html#aaeb2ac6a36ce7bbfb351f272ff724cf8">isLeaf()</a> returns false. Calling this method on a leaf node will throw an exception. </p>

</div>
</div>
<a id="aaf0f3cd4f006d876302502182569ecee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf0f3cd4f006d876302502182569ecee">&#9670;&nbsp;</a></span>getNumFaceGroups()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Ogre::BspNode::getNumFaceGroups </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_s_d_l__opengles2__gl2ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of faces contained in this leaf node. Should only be called on a leaf node. </p>

</div>
</div>
<a id="ab13aab15a8670d2aac451da8b97251cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab13aab15a8670d2aac451da8b97251cc">&#9670;&nbsp;</a></span>getObjects()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_bsp_node.html#af86ad5b76b6e2327db0e702d4216ad30">IntersectingObjectSet</a>&amp; Ogre::BspNode::getObjects </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_s_d_l__opengles2__gl2ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae4dd978cc8a7a6bcd35921d9ee37c5c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4dd978cc8a7a6bcd35921d9ee37c5c7">&#9670;&nbsp;</a></span>getSide()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_plane.html#aa5d44b14d6f032f3e0a26e83589180bc">Plane::Side</a> Ogre::BspNode::getSide </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines which side of the splitting plane a worldspace point is. This method should only be called on a splitting node, i.e. where <a class="el" href="class_ogre_1_1_bsp_node.html#aaeb2ac6a36ce7bbfb351f272ff724cf8">isLeaf()</a> returns false. Calling this method on a leaf node will throw an exception. </p>

</div>
</div>
<a id="ac31674d044317b6e900efe52acb0439f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac31674d044317b6e900efe52acb0439f">&#9670;&nbsp;</a></span>getSolidBrushes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_bsp_node.html#ade6cf2f9bdd72538d3b2863bfb598f98">NodeBrushList</a>&amp; Ogre::BspNode::getSolidBrushes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_s_d_l__opengles2__gl2ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main brush memory held on level. </p>
<p>Get the list of solid Brushes for this node. </p><dl class="section remark"><dt>Remarks</dt><dd>Only applicable for leaf nodes. </dd></dl>

</div>
</div>
<a id="aaf82d30b03b4819d3f4cd161ca53f3bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf82d30b03b4819d3f4cd161ca53f3bf">&#9670;&nbsp;</a></span>getSplitPlane()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_plane.html">Plane</a>&amp; Ogre::BspNode::getSplitPlane </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_s_d_l__opengles2__gl2ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns details of the plane which is used to subdivide the space of his node's children. This method should only be called on a splitting node, i.e. where <a class="el" href="class_ogre_1_1_bsp_node.html#aaeb2ac6a36ce7bbfb351f272ff724cf8">isLeaf()</a> returns false. Calling this method on a leaf node will throw an exception. </p>

</div>
</div>
<a id="aaeb2ac6a36ce7bbfb351f272ff724cf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeb2ac6a36ce7bbfb351f272ff724cf8">&#9670;&nbsp;</a></span>isLeaf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::BspNode::isLeaf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_s_d_l__opengles2__gl2ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if this node is a leaf (i.e. contains geometry) or false if it is a splitting plane. A <a class="el" href="class_ogre_1_1_bsp_node.html">BspNode</a> can either be a splitting plane (the typical representation of a BSP node) or an undivided region contining geometry (a leaf node). <a class="el" href="namespace_ogre.html">Ogre</a> represents both using the same class for simplicity of tree walking. However it is important that you use this method to determine which type you are dealing with, since certain methods are only supported with one of the subtypes. Details are given in the individual methods. Note that I could have represented splitting / leaf nodes as a class hierarchy but the virtual methods / run-time type identification would have a performance hit, and it would not make the code much (any?) simpler anyway. I think this is a fair trade-off in this case. </p>

</div>
</div>
<a id="a89db45619ae315c31cd3880aad56b94c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89db45619ae315c31cd3880aad56b94c">&#9670;&nbsp;</a></span>isLeafVisible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::BspNode::isLeafVisible </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_bsp_node.html">BspNode</a> *&#160;</td>
          <td class="paramname"><em>leaf</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines if the passed in node (must also be a leaf) is visible from this leaf. Must only be called on a leaf node, and the parameter must also be a leaf node. If this method returns true, then the leaf passed in is visible from this leaf. Note that internally this uses the Potentially Visible Set (PVS) which is precalculated and stored with the BSP level. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a8c663a45872e4b89850c3ba482beaef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c663a45872e4b89850c3ba482beaef5">&#9670;&nbsp;</a></span>BspLevel</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="class_ogre_1_1_bsp_level.html">BspLevel</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1092a75e646a2cecdd62b54da97a09bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1092a75e646a2cecdd62b54da97a09bc">&#9670;&nbsp;</a></span>operator<<</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_bsp_node.html">BspNode</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aaeaabf9f30966c28d7131a4e4d0f496b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeaabf9f30966c28d7131a4e4d0f496b">&#9670;&nbsp;</a></span>mBack</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_bsp_node.html">BspNode</a>* Ogre::BspNode::mBack</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to the node behind this non-leaf node. </p>

</div>
</div>
<a id="a36a2fd9dac5864edd6169b3e9d188dda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36a2fd9dac5864edd6169b3e9d188dda">&#9670;&nbsp;</a></span>mBounds</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_axis_aligned_box.html">AxisAlignedBox</a> Ogre::BspNode::mBounds</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The axis-aligned box which bounds node if it is a leaf. </p>

</div>
</div>
<a id="ac8268f4997a3e9d91fcd2a1f8aeee3b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8268f4997a3e9d91fcd2a1f8aeee3b9">&#9670;&nbsp;</a></span>mFaceGroupStart</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Ogre::BspNode::mFaceGroupStart</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Index to the part of the main leaf facegroup index buffer(held in BspLevel) for this leaf. This leaf uses mNumFaceGroups from this pointer onwards. From here you use the index in this buffer to look up the actual face. Note that again for simplicity and bulk memory allocation the face group list itself is allocated by the <a class="el" href="class_ogre_1_1_bsp_level.html">BspLevel</a> for all nodes, and each leaf node is given a section of it to work on. This saves lots of small memory allocations / deallocations which limits memory fragmentation. </p>

</div>
</div>
<a id="ae8e71ff943c560f8603242f47db40478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8e71ff943c560f8603242f47db40478">&#9670;&nbsp;</a></span>mFront</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_bsp_node.html">BspNode</a>* Ogre::BspNode::mFront</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to the node in front of this non-leaf node. </p>

</div>
</div>
<a id="abe0862d80295c90d94246abb2b951a91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe0862d80295c90d94246abb2b951a91">&#9670;&nbsp;</a></span>mIsLeaf</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::BspNode::mIsLeaf</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Back-reference to containing level. </p>

</div>
</div>
<a id="a9b0966df9e5b094abc9bcab656c9c6bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b0966df9e5b094abc9bcab656c9c6bd">&#9670;&nbsp;</a></span>mMovables</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_bsp_node.html#af86ad5b76b6e2327db0e702d4216ad30">IntersectingObjectSet</a> Ogre::BspNode::mMovables</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a844b03dd60cac3277bcd2f2c262bae18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a844b03dd60cac3277bcd2f2c262bae18">&#9670;&nbsp;</a></span>mNumFaceGroups</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Ogre::BspNode::mNumFaceGroups</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of face groups in this node if it is a leaf. </p>

</div>
</div>
<a id="a9736c757eeb9cd899c511b9de8b43d37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9736c757eeb9cd899c511b9de8b43d37">&#9670;&nbsp;</a></span>mOwner</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_bsp_level.html">BspLevel</a>* Ogre::BspNode::mOwner</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aff118c3b93e2ced54e9345d96e87d384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff118c3b93e2ced54e9345d96e87d384">&#9670;&nbsp;</a></span>mSolidBrushes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_bsp_node.html#ade6cf2f9bdd72538d3b2863bfb598f98">NodeBrushList</a> Ogre::BspNode::mSolidBrushes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acce6facb22a7c2363f48d9283de78632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acce6facb22a7c2363f48d9283de78632">&#9670;&nbsp;</a></span>mSplitPlane</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_plane.html">Plane</a> Ogre::BspNode::mSplitPlane</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The plane which splits space in a non-leaf node. Note that nodes do not allocate the memory for other nodes - for simplicity and bulk-allocation of memory the <a class="el" href="class_ogre_1_1_bsp_level.html">BspLevel</a> is responsible for assigning enough memory for all nodes in one go. </p>

</div>
</div>
<a id="ad69a374aa92008df8d65b33eb30c207d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad69a374aa92008df8d65b33eb30c207d">&#9670;&nbsp;</a></span>mVisCluster</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Ogre::BspNode::mVisCluster</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The cluster number of this leaf. Leaf nodes are assigned to 'clusters' of nodes, which are used to group nodes together for visibility testing. There is a lookup table which is used to determine if one cluster of leaves is visible from another cluster. Whilst it would be possible to expand all this out so that each node had a list of pointers to other visible nodes, this would be very expensive in terms of storage (using the cluster method there is a table which is 1-bit squared per cluster, rounded up to the nearest byte obviously, which uses far less space than 4-bytes per linked node per source node). Of course the limitation here is that you have to each leaf in turn to determine if it is visible rather than just following a list, but since this is only done once per frame this is not such a big overhead. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>dependencies/OGRE-1.10.9/include/OGRE/Plugins/BSPSceneManager/<a class="el" href="_ogre_bsp_node_8h_source.html">OgreBspNode.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ogre.html">Ogre</a></li><li class="navelem"><a class="el" href="class_ogre_1_1_bsp_node.html">BspNode</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
