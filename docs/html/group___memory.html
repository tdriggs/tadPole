<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tadPole: Memory</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tadPole
   </div>
   <div id="projectbrief">A simple game engine to create simple games.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___memory.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Memory<div class="ingroups"><a class="el" href="group___core.html">Core</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:_ogre_memory_allocator_config_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_ogre_memory_allocator_config_8h.html">OgreMemoryAllocatorConfig.h</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_ogre"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_ogre.html">Ogre</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_aligned_memory.html">Ogre::AlignedMemory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_allocated_object.html">Ogre::AllocatedObject&lt; Alloc &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_ned_alloc_impl.html">Ogre::NedAllocImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_ned_alloc_policy.html">Ogre::NedAllocPolicy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_ned_aligned_alloc_policy.html">Ogre::NedAlignedAllocPolicy&lt; Alignment &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_ned_pooling_impl.html">Ogre::NedPoolingImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_ned_pooling_policy.html">Ogre::NedPoolingPolicy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_ned_pooling_aligned_policy.html">Ogre::NedPoolingAlignedPolicy&lt; Alignment &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_std_alloc_policy.html">Ogre::StdAllocPolicy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_std_aligned_alloc_policy.html">Ogre::StdAlignedAllocPolicy&lt; Alignment &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ogre_1_1_s_t_l_allocator_base.html">Ogre::STLAllocatorBase&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ogre_1_1_s_t_l_allocator_base_3_01const_01_t_01_4.html">Ogre::STLAllocatorBase&lt; const T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_s_t_l_allocator.html">Ogre::STLAllocator&lt; T, AllocPolicy &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga2382b731c3d757f74f0fedf2b14ed9d6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___memory.html#ga2382b731c3d757f74f0fedf2b14ed9d6">OGRE_MALLOC</a>(bytes,  category)&#160;&#160;&#160;::<a class="el" href="class_ogre_1_1_categorised_alloc_policy.html">Ogre::CategorisedAllocPolicy</a>&lt;category&gt;::allocateBytes(bytes)</td></tr>
<tr class="memdesc:ga2382b731c3d757f74f0fedf2b14ed9d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a block of raw memory, and indicate the category of usage.  <a href="#ga2382b731c3d757f74f0fedf2b14ed9d6">More...</a><br /></td></tr>
<tr class="separator:ga2382b731c3d757f74f0fedf2b14ed9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3211e4a6a806aa789b38dce2432ef472"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___memory.html#ga3211e4a6a806aa789b38dce2432ef472">OGRE_ALLOC_T</a>(T,  <a class="el" href="glext_8h.html#a619bc20e8198de3bd3f3d7fc34de66b2">count</a>,  category)&#160;&#160;&#160;static_cast&lt;T*&gt;(::<a class="el" href="class_ogre_1_1_categorised_alloc_policy.html">Ogre::CategorisedAllocPolicy</a>&lt;category&gt;::allocateBytes(sizeof(T)*(<a class="el" href="glext_8h.html#a619bc20e8198de3bd3f3d7fc34de66b2">count</a>)))</td></tr>
<tr class="memdesc:ga3211e4a6a806aa789b38dce2432ef472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a block of memory for a primitive type, and indicate the category of usage.  <a href="#ga3211e4a6a806aa789b38dce2432ef472">More...</a><br /></td></tr>
<tr class="separator:ga3211e4a6a806aa789b38dce2432ef472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfd8dc937cf390c7bff05495f0dc10cf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___memory.html#gacfd8dc937cf390c7bff05495f0dc10cf">OGRE_FREE</a>(ptr,  category)&#160;&#160;&#160;::<a class="el" href="class_ogre_1_1_categorised_alloc_policy.html">Ogre::CategorisedAllocPolicy</a>&lt;category&gt;::deallocateBytes((<a class="el" href="_s_d_l__opengles2__gl2ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>*)ptr)</td></tr>
<tr class="memdesc:gacfd8dc937cf390c7bff05495f0dc10cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the memory allocated with OGRE_MALLOC or OGRE_ALLOC_T. Category is required to be restated to ensure the matching policy is used.  <a href="#gacfd8dc937cf390c7bff05495f0dc10cf">More...</a><br /></td></tr>
<tr class="separator:gacfd8dc937cf390c7bff05495f0dc10cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46253f12658ce0922e982a8a9dd11312"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___memory.html#ga46253f12658ce0922e982a8a9dd11312">OGRE_NEW_T</a>(T,  category)&#160;&#160;&#160;new (::<a class="el" href="class_ogre_1_1_categorised_alloc_policy.html">Ogre::CategorisedAllocPolicy</a>&lt;category&gt;::allocateBytes(sizeof(T))) T</td></tr>
<tr class="memdesc:ga46253f12658ce0922e982a8a9dd11312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate space for one primitive type, external type or non-virtual type with constructor parameters.  <a href="#ga46253f12658ce0922e982a8a9dd11312">More...</a><br /></td></tr>
<tr class="separator:ga46253f12658ce0922e982a8a9dd11312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c428bbdad197df6a4ba22d3c1d48f5a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___memory.html#ga6c428bbdad197df6a4ba22d3c1d48f5a">OGRE_NEW_ARRAY_T</a>(T,  <a class="el" href="glext_8h.html#a619bc20e8198de3bd3f3d7fc34de66b2">count</a>,  category)&#160;&#160;&#160;::<a class="el" href="group___memory.html#gae542663b49eb68a74336d84e11ba0b9c">Ogre::constructN</a>(static_cast&lt;T*&gt;(::<a class="el" href="class_ogre_1_1_categorised_alloc_policy.html">Ogre::CategorisedAllocPolicy</a>&lt;category&gt;::allocateBytes(sizeof(T)*(<a class="el" href="glext_8h.html#a619bc20e8198de3bd3f3d7fc34de66b2">count</a>))), <a class="el" href="glext_8h.html#a619bc20e8198de3bd3f3d7fc34de66b2">count</a>)</td></tr>
<tr class="memdesc:ga6c428bbdad197df6a4ba22d3c1d48f5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a block of memory for 'count' primitive types - do not use for classes that inherit from AllocatedObject.  <a href="#ga6c428bbdad197df6a4ba22d3c1d48f5a">More...</a><br /></td></tr>
<tr class="separator:ga6c428bbdad197df6a4ba22d3c1d48f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b0974da65362dd8a14071e7f6e4daca"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___memory.html#ga0b0974da65362dd8a14071e7f6e4daca">OGRE_DELETE_T</a>(ptr,  T,  category)&#160;&#160;&#160;if(ptr){(ptr)-&gt;~T(); ::<a class="el" href="class_ogre_1_1_categorised_alloc_policy.html">Ogre::CategorisedAllocPolicy</a>&lt;category&gt;::deallocateBytes((<a class="el" href="_s_d_l__opengles2__gl2ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>*)ptr);}</td></tr>
<tr class="memdesc:ga0b0974da65362dd8a14071e7f6e4daca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the memory allocated with OGRE_NEW_T. Category is required to be restated to ensure the matching policy is used.  <a href="#ga0b0974da65362dd8a14071e7f6e4daca">More...</a><br /></td></tr>
<tr class="separator:ga0b0974da65362dd8a14071e7f6e4daca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9f9fa14d424036dc5881cbcb3c741e0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___memory.html#gab9f9fa14d424036dc5881cbcb3c741e0">OGRE_DELETE_ARRAY_T</a>(ptr,  T,  <a class="el" href="glext_8h.html#a619bc20e8198de3bd3f3d7fc34de66b2">count</a>,  category)&#160;&#160;&#160;if(ptr){for (<a class="el" href="_s_d_l__config_8h.html#a7c94ea6f8948649f8d181ae55911eeaf">size_t</a> <a class="el" href="glext_8h.html#a0f71581a41fd2264c8944126dabbd010">b</a> = 0; <a class="el" href="glext_8h.html#a0f71581a41fd2264c8944126dabbd010">b</a> &lt; <a class="el" href="glext_8h.html#a619bc20e8198de3bd3f3d7fc34de66b2">count</a>; ++<a class="el" href="glext_8h.html#a0f71581a41fd2264c8944126dabbd010">b</a>) { (ptr)[<a class="el" href="glext_8h.html#a0f71581a41fd2264c8944126dabbd010">b</a>].~T();} ::<a class="el" href="class_ogre_1_1_categorised_alloc_policy.html">Ogre::CategorisedAllocPolicy</a>&lt;category&gt;::deallocateBytes((<a class="el" href="_s_d_l__opengles2__gl2ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>*)ptr);}</td></tr>
<tr class="memdesc:gab9f9fa14d424036dc5881cbcb3c741e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the memory allocated with OGRE_NEW_ARRAY_T. Category is required to be restated to ensure the matching policy is used, count and type to call destructor.  <a href="#gab9f9fa14d424036dc5881cbcb3c741e0">More...</a><br /></td></tr>
<tr class="separator:gab9f9fa14d424036dc5881cbcb3c741e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd7ddaef10ac9ea1ffbd18902167b9a2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___memory.html#gafd7ddaef10ac9ea1ffbd18902167b9a2">OGRE_MALLOC_SIMD</a>(bytes,  category)&#160;&#160;&#160;::<a class="el" href="class_ogre_1_1_categorised_align_alloc_policy.html">Ogre::CategorisedAlignAllocPolicy</a>&lt;category&gt;::allocateBytes(bytes)</td></tr>
<tr class="memdesc:gafd7ddaef10ac9ea1ffbd18902167b9a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a block of raw memory aligned to SIMD boundaries, and indicate the category of usage.  <a href="#gafd7ddaef10ac9ea1ffbd18902167b9a2">More...</a><br /></td></tr>
<tr class="separator:gafd7ddaef10ac9ea1ffbd18902167b9a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga876cf0a4c7e209ce798b5e6708ca2343"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___memory.html#ga876cf0a4c7e209ce798b5e6708ca2343">OGRE_MALLOC_ALIGN</a>(bytes,  category,  align)&#160;&#160;&#160;::<a class="el" href="class_ogre_1_1_categorised_align_alloc_policy.html">Ogre::CategorisedAlignAllocPolicy</a>&lt;category, align&gt;::allocateBytes(bytes)</td></tr>
<tr class="memdesc:ga876cf0a4c7e209ce798b5e6708ca2343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a block of raw memory aligned to user defined boundaries, and indicate the category of usage.  <a href="#ga876cf0a4c7e209ce798b5e6708ca2343">More...</a><br /></td></tr>
<tr class="separator:ga876cf0a4c7e209ce798b5e6708ca2343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga728b719dd1425d46a78fe87d6f9ea6a5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___memory.html#ga728b719dd1425d46a78fe87d6f9ea6a5">OGRE_ALLOC_T_SIMD</a>(T,  <a class="el" href="glext_8h.html#a619bc20e8198de3bd3f3d7fc34de66b2">count</a>,  category)&#160;&#160;&#160;static_cast&lt;T*&gt;(::<a class="el" href="class_ogre_1_1_categorised_align_alloc_policy.html">Ogre::CategorisedAlignAllocPolicy</a>&lt;category&gt;::allocateBytes(sizeof(T)*(<a class="el" href="glext_8h.html#a619bc20e8198de3bd3f3d7fc34de66b2">count</a>)))</td></tr>
<tr class="memdesc:ga728b719dd1425d46a78fe87d6f9ea6a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a block of memory for a primitive type aligned to SIMD boundaries, and indicate the category of usage.  <a href="#ga728b719dd1425d46a78fe87d6f9ea6a5">More...</a><br /></td></tr>
<tr class="separator:ga728b719dd1425d46a78fe87d6f9ea6a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc79c14937612b02ac50631c08666b26"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___memory.html#gafc79c14937612b02ac50631c08666b26">OGRE_ALLOC_T_ALIGN</a>(T,  <a class="el" href="glext_8h.html#a619bc20e8198de3bd3f3d7fc34de66b2">count</a>,  category,  align)&#160;&#160;&#160;static_cast&lt;T*&gt;(::<a class="el" href="class_ogre_1_1_categorised_align_alloc_policy.html">Ogre::CategorisedAlignAllocPolicy</a>&lt;category, align&gt;::allocateBytes(sizeof(T)*(<a class="el" href="glext_8h.html#a619bc20e8198de3bd3f3d7fc34de66b2">count</a>)))</td></tr>
<tr class="memdesc:gafc79c14937612b02ac50631c08666b26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a block of memory for a primitive type aligned to user defined boundaries, and indicate the category of usage.  <a href="#gafc79c14937612b02ac50631c08666b26">More...</a><br /></td></tr>
<tr class="separator:gafc79c14937612b02ac50631c08666b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7501eb098fc6671420c628dc80af2a8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___memory.html#gaf7501eb098fc6671420c628dc80af2a8">OGRE_FREE_SIMD</a>(ptr,  category)&#160;&#160;&#160;::<a class="el" href="class_ogre_1_1_categorised_align_alloc_policy.html">Ogre::CategorisedAlignAllocPolicy</a>&lt;category&gt;::deallocateBytes((<a class="el" href="_s_d_l__opengles2__gl2ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>*)ptr)</td></tr>
<tr class="memdesc:gaf7501eb098fc6671420c628dc80af2a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the memory allocated with either OGRE_MALLOC_SIMD or OGRE_ALLOC_T_SIMD. Category is required to be restated to ensure the matching policy is used.  <a href="#gaf7501eb098fc6671420c628dc80af2a8">More...</a><br /></td></tr>
<tr class="separator:gaf7501eb098fc6671420c628dc80af2a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa06d37a211e3da357b8457ccdb4decac"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___memory.html#gaa06d37a211e3da357b8457ccdb4decac">OGRE_FREE_ALIGN</a>(ptr,  category,  align)&#160;&#160;&#160;::<a class="el" href="class_ogre_1_1_categorised_align_alloc_policy.html">Ogre::CategorisedAlignAllocPolicy</a>&lt;category, align&gt;::deallocateBytes((<a class="el" href="_s_d_l__opengles2__gl2ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>*)ptr)</td></tr>
<tr class="memdesc:gaa06d37a211e3da357b8457ccdb4decac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the memory allocated with either OGRE_MALLOC_ALIGN or OGRE_ALLOC_T_ALIGN. Category is required to be restated to ensure the matching policy is used.  <a href="#gaa06d37a211e3da357b8457ccdb4decac">More...</a><br /></td></tr>
<tr class="separator:gaa06d37a211e3da357b8457ccdb4decac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f7eef98b7fe3ba9f36630b787d603b1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___memory.html#ga2f7eef98b7fe3ba9f36630b787d603b1">OGRE_NEW_T_SIMD</a>(T,  category)&#160;&#160;&#160;new (::<a class="el" href="class_ogre_1_1_categorised_align_alloc_policy.html">Ogre::CategorisedAlignAllocPolicy</a>&lt;category&gt;::allocateBytes(sizeof(T))) T</td></tr>
<tr class="memdesc:ga2f7eef98b7fe3ba9f36630b787d603b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate space for one primitive type, external type or non-virtual type aligned to SIMD boundaries.  <a href="#ga2f7eef98b7fe3ba9f36630b787d603b1">More...</a><br /></td></tr>
<tr class="separator:ga2f7eef98b7fe3ba9f36630b787d603b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa55846bae98cf66fd5158ad0d4d623bb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___memory.html#gaa55846bae98cf66fd5158ad0d4d623bb">OGRE_NEW_ARRAY_T_SIMD</a>(T,  <a class="el" href="glext_8h.html#a619bc20e8198de3bd3f3d7fc34de66b2">count</a>,  category)&#160;&#160;&#160;::<a class="el" href="group___memory.html#gae542663b49eb68a74336d84e11ba0b9c">Ogre::constructN</a>(static_cast&lt;T*&gt;(::<a class="el" href="class_ogre_1_1_categorised_align_alloc_policy.html">Ogre::CategorisedAlignAllocPolicy</a>&lt;category&gt;::allocateBytes(sizeof(T)*(<a class="el" href="glext_8h.html#a619bc20e8198de3bd3f3d7fc34de66b2">count</a>))), <a class="el" href="glext_8h.html#a619bc20e8198de3bd3f3d7fc34de66b2">count</a>)</td></tr>
<tr class="memdesc:gaa55846bae98cf66fd5158ad0d4d623bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a block of memory for 'count' primitive types aligned to SIMD boundaries - do not use for classes that inherit from AllocatedObject.  <a href="#gaa55846bae98cf66fd5158ad0d4d623bb">More...</a><br /></td></tr>
<tr class="separator:gaa55846bae98cf66fd5158ad0d4d623bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a5d598e538371f2fca9608277051347"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___memory.html#ga1a5d598e538371f2fca9608277051347">OGRE_DELETE_T_SIMD</a>(ptr,  T,  category)&#160;&#160;&#160;if(ptr){(ptr)-&gt;~T(); ::<a class="el" href="class_ogre_1_1_categorised_align_alloc_policy.html">Ogre::CategorisedAlignAllocPolicy</a>&lt;category&gt;::deallocateBytes((<a class="el" href="_s_d_l__opengles2__gl2ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>*)ptr);}</td></tr>
<tr class="memdesc:ga1a5d598e538371f2fca9608277051347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the memory allocated with OGRE_NEW_T_SIMD. Category is required to be restated to ensure the matching policy is used.  <a href="#ga1a5d598e538371f2fca9608277051347">More...</a><br /></td></tr>
<tr class="separator:ga1a5d598e538371f2fca9608277051347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ceedc1e74432821ffab664232c12d04"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___memory.html#ga3ceedc1e74432821ffab664232c12d04">OGRE_DELETE_ARRAY_T_SIMD</a>(ptr,  T,  <a class="el" href="glext_8h.html#a619bc20e8198de3bd3f3d7fc34de66b2">count</a>,  category)&#160;&#160;&#160;if(ptr){for (<a class="el" href="_s_d_l__config_8h.html#a7c94ea6f8948649f8d181ae55911eeaf">size_t</a> <a class="el" href="glext_8h.html#a0f71581a41fd2264c8944126dabbd010">b</a> = 0; <a class="el" href="glext_8h.html#a0f71581a41fd2264c8944126dabbd010">b</a> &lt; <a class="el" href="glext_8h.html#a619bc20e8198de3bd3f3d7fc34de66b2">count</a>; ++<a class="el" href="glext_8h.html#a0f71581a41fd2264c8944126dabbd010">b</a>) { (ptr)[<a class="el" href="glext_8h.html#a0f71581a41fd2264c8944126dabbd010">b</a>].~T();} ::<a class="el" href="class_ogre_1_1_categorised_align_alloc_policy.html">Ogre::CategorisedAlignAllocPolicy</a>&lt;category&gt;::deallocateBytes((<a class="el" href="_s_d_l__opengles2__gl2ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>*)ptr);}</td></tr>
<tr class="memdesc:ga3ceedc1e74432821ffab664232c12d04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the memory allocated with OGRE_NEW_ARRAY_T_SIMD. Category is required to be restated to ensure the matching policy is used, count and type to call destructor.  <a href="#ga3ceedc1e74432821ffab664232c12d04">More...</a><br /></td></tr>
<tr class="separator:ga3ceedc1e74432821ffab664232c12d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c928813aac2c96ae5cc775aacd3e26d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___memory.html#ga4c928813aac2c96ae5cc775aacd3e26d">OGRE_NEW_T_ALIGN</a>(T,  category,  align)&#160;&#160;&#160;new (::<a class="el" href="class_ogre_1_1_categorised_align_alloc_policy.html">Ogre::CategorisedAlignAllocPolicy</a>&lt;category, align&gt;::allocateBytes(sizeof(T))) T</td></tr>
<tr class="memdesc:ga4c928813aac2c96ae5cc775aacd3e26d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate space for one primitive type, external type or non-virtual type aligned to user defined boundaries.  <a href="#ga4c928813aac2c96ae5cc775aacd3e26d">More...</a><br /></td></tr>
<tr class="separator:ga4c928813aac2c96ae5cc775aacd3e26d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51224b5c8af6fd85e192975ebe20139b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___memory.html#ga51224b5c8af6fd85e192975ebe20139b">OGRE_NEW_ARRAY_T_ALIGN</a>(T,  <a class="el" href="glext_8h.html#a619bc20e8198de3bd3f3d7fc34de66b2">count</a>,  category,  align)&#160;&#160;&#160;::<a class="el" href="group___memory.html#gae542663b49eb68a74336d84e11ba0b9c">Ogre::constructN</a>(static_cast&lt;T*&gt;(::<a class="el" href="class_ogre_1_1_categorised_align_alloc_policy.html">Ogre::CategorisedAlignAllocPolicy</a>&lt;category, align&gt;::allocateBytes(sizeof(T)*(<a class="el" href="glext_8h.html#a619bc20e8198de3bd3f3d7fc34de66b2">count</a>))), <a class="el" href="glext_8h.html#a619bc20e8198de3bd3f3d7fc34de66b2">count</a>)</td></tr>
<tr class="memdesc:ga51224b5c8af6fd85e192975ebe20139b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a block of memory for 'count' primitive types aligned to user defined boundaries - do not use for classes that inherit from AllocatedObject.  <a href="#ga51224b5c8af6fd85e192975ebe20139b">More...</a><br /></td></tr>
<tr class="separator:ga51224b5c8af6fd85e192975ebe20139b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga076af127ea8efe2284e03ab4c2057603"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___memory.html#ga076af127ea8efe2284e03ab4c2057603">OGRE_DELETE_T_ALIGN</a>(ptr,  T,  category,  align)&#160;&#160;&#160;if(ptr){(ptr)-&gt;~T(); ::<a class="el" href="class_ogre_1_1_categorised_align_alloc_policy.html">Ogre::CategorisedAlignAllocPolicy</a>&lt;category, align&gt;::deallocateBytes((<a class="el" href="_s_d_l__opengles2__gl2ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>*)ptr);}</td></tr>
<tr class="memdesc:ga076af127ea8efe2284e03ab4c2057603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the memory allocated with OGRE_NEW_T_ALIGN. Category is required to be restated to ensure the matching policy is used.  <a href="#ga076af127ea8efe2284e03ab4c2057603">More...</a><br /></td></tr>
<tr class="separator:ga076af127ea8efe2284e03ab4c2057603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25e1e9ce907fc367cc735465c940da23"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___memory.html#ga25e1e9ce907fc367cc735465c940da23">OGRE_DELETE_ARRAY_T_ALIGN</a>(ptr,  T,  <a class="el" href="glext_8h.html#a619bc20e8198de3bd3f3d7fc34de66b2">count</a>,  category,  align)&#160;&#160;&#160;if(ptr){for (<a class="el" href="_s_d_l__config_8h.html#a7c94ea6f8948649f8d181ae55911eeaf">size_t</a> _b = 0; _b &lt; <a class="el" href="glext_8h.html#a619bc20e8198de3bd3f3d7fc34de66b2">count</a>; ++_b) { (ptr)[_b].~T();} ::<a class="el" href="class_ogre_1_1_categorised_align_alloc_policy.html">Ogre::CategorisedAlignAllocPolicy</a>&lt;category, align&gt;::deallocateBytes((<a class="el" href="_s_d_l__opengles2__gl2ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>*)ptr);}</td></tr>
<tr class="memdesc:ga25e1e9ce907fc367cc735465c940da23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the memory allocated with OGRE_NEW_ARRAY_T_ALIGN. Category is required to be restated to ensure the matching policy is used, count and type to call destructor.  <a href="#ga25e1e9ce907fc367cc735465c940da23">More...</a><br /></td></tr>
<tr class="separator:ga25e1e9ce907fc367cc735465c940da23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5fc1358fd5a889de0a06d07e45df1ff"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___memory.html#gab5fc1358fd5a889de0a06d07e45df1ff">OGRE_NEW</a>&#160;&#160;&#160;new</td></tr>
<tr class="separator:gab5fc1358fd5a889de0a06d07e45df1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad18eff671a00617b21c8e35a7f545690"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___memory.html#gad18eff671a00617b21c8e35a7f545690">OGRE_DELETE</a>&#160;&#160;&#160;delete</td></tr>
<tr class="separator:gad18eff671a00617b21c8e35a7f545690"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga830fab51be174d6f2849857cb1abb36a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___memory.html#ga830fab51be174d6f2849857cb1abb36a">Ogre::MemoryCategory</a> { <br />
&#160;&#160;<a class="el" href="group___memory.html#gga830fab51be174d6f2849857cb1abb36aa8ac29a2852b1b5fe79d1659b16f521cb">Ogre::MEMCATEGORY_GENERAL</a> = 0, 
<a class="el" href="group___memory.html#gga830fab51be174d6f2849857cb1abb36aaf9e04ff475de4493bc942a9c73da4c2e">Ogre::MEMCATEGORY_GEOMETRY</a> = 1, 
<a class="el" href="group___memory.html#gga830fab51be174d6f2849857cb1abb36aa24267bedbd1115a8f208e4ee355693e4">Ogre::MEMCATEGORY_ANIMATION</a> = 2, 
<a class="el" href="group___memory.html#gga830fab51be174d6f2849857cb1abb36aa8a55fa0fcaa8403bb51ca210f882ed90">Ogre::MEMCATEGORY_SCENE_CONTROL</a> = 3, 
<br />
&#160;&#160;<a class="el" href="group___memory.html#gga830fab51be174d6f2849857cb1abb36aaffe1e3d51d961175f8f2756611439181">Ogre::MEMCATEGORY_SCENE_OBJECTS</a> = 4, 
<a class="el" href="group___memory.html#gga830fab51be174d6f2849857cb1abb36aa04bad2e7f64cc2b6f4cda9f56b59e5b4">Ogre::MEMCATEGORY_RESOURCE</a> = 5, 
<a class="el" href="group___memory.html#gga830fab51be174d6f2849857cb1abb36aaa037d2f843117cd5fb39ec064d7ff23b">Ogre::MEMCATEGORY_SCRIPTING</a> = 6, 
<a class="el" href="group___memory.html#gga830fab51be174d6f2849857cb1abb36aa29274489311d683a88676dbb1c779788">Ogre::MEMCATEGORY_RENDERSYS</a> = 7, 
<br />
&#160;&#160;<a class="el" href="group___memory.html#gga830fab51be174d6f2849857cb1abb36aa4ff2b9446477e2ea4170b09d8aaa1b67">Ogre::MEMCATEGORY_COUNT</a> = 8
<br />
 }</td></tr>
<tr class="separator:ga830fab51be174d6f2849857cb1abb36a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae542663b49eb68a74336d84e11ba0b9c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae542663b49eb68a74336d84e11ba0b9c"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___memory.html#gae542663b49eb68a74336d84e11ba0b9c">Ogre::constructN</a> (T *basePtr, <a class="el" href="_s_d_l__config_8h.html#a7c94ea6f8948649f8d181ae55911eeaf">size_t</a> <a class="el" href="glext_8h.html#a619bc20e8198de3bd3f3d7fc34de66b2">count</a>)</td></tr>
<tr class="separator:gae542663b49eb68a74336d84e11ba0b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5b83b2ba3ce965e3d8dd129c93ee43b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T2 , typename P &gt; </td></tr>
<tr class="memitem:gaa5b83b2ba3ce965e3d8dd129c93ee43b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___memory.html#gaa5b83b2ba3ce965e3d8dd129c93ee43b">Ogre::operator==</a> (<a class="el" href="class_ogre_1_1_s_t_l_allocator.html">STLAllocator</a>&lt; T, P &gt; const &amp;, <a class="el" href="class_ogre_1_1_s_t_l_allocator.html">STLAllocator</a>&lt; T2, P &gt; const &amp;)</td></tr>
<tr class="separator:gaa5b83b2ba3ce965e3d8dd129c93ee43b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa34a630f2287087875d360c454a0fb48"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename OtherAllocator &gt; </td></tr>
<tr class="memitem:gaa34a630f2287087875d360c454a0fb48"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___memory.html#gaa34a630f2287087875d360c454a0fb48">Ogre::operator==</a> (<a class="el" href="class_ogre_1_1_s_t_l_allocator.html">STLAllocator</a>&lt; T, P &gt; const &amp;, OtherAllocator const &amp;)</td></tr>
<tr class="separator:gaa34a630f2287087875d360c454a0fb48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34a9308dc656f694883718bf8fa4f1c2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T2 , typename P &gt; </td></tr>
<tr class="memitem:ga34a9308dc656f694883718bf8fa4f1c2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___memory.html#ga34a9308dc656f694883718bf8fa4f1c2">Ogre::operator!=</a> (<a class="el" href="class_ogre_1_1_s_t_l_allocator.html">STLAllocator</a>&lt; T, P &gt; const &amp;, <a class="el" href="class_ogre_1_1_s_t_l_allocator.html">STLAllocator</a>&lt; T2, P &gt; const &amp;)</td></tr>
<tr class="separator:ga34a9308dc656f694883718bf8fa4f1c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cec9339a4ab3eaf48c767087cd7f400"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename OtherAllocator &gt; </td></tr>
<tr class="memitem:ga0cec9339a4ab3eaf48c767087cd7f400"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___memory.html#ga0cec9339a4ab3eaf48c767087cd7f400">Ogre::operator!=</a> (<a class="el" href="class_ogre_1_1_s_t_l_allocator.html">STLAllocator</a>&lt; T, P &gt; const &amp;, OtherAllocator const &amp;)</td></tr>
<tr class="separator:ga0cec9339a4ab3eaf48c767087cd7f400"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga3211e4a6a806aa789b38dce2432ef472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3211e4a6a806aa789b38dce2432ef472">&#9670;&nbsp;</a></span>OGRE_ALLOC_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OGRE_ALLOC_T</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="glext_8h.html#a619bc20e8198de3bd3f3d7fc34de66b2">count</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">category&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;static_cast&lt;T*&gt;(::<a class="el" href="class_ogre_1_1_categorised_alloc_policy.html">Ogre::CategorisedAllocPolicy</a>&lt;category&gt;::allocateBytes(sizeof(T)*(<a class="el" href="glext_8h.html#a619bc20e8198de3bd3f3d7fc34de66b2">count</a>)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a block of memory for a primitive type, and indicate the category of usage. </p>

</div>
</div>
<a id="gafc79c14937612b02ac50631c08666b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc79c14937612b02ac50631c08666b26">&#9670;&nbsp;</a></span>OGRE_ALLOC_T_ALIGN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OGRE_ALLOC_T_ALIGN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="glext_8h.html#a619bc20e8198de3bd3f3d7fc34de66b2">count</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">category, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">align&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;static_cast&lt;T*&gt;(::<a class="el" href="class_ogre_1_1_categorised_align_alloc_policy.html">Ogre::CategorisedAlignAllocPolicy</a>&lt;category, align&gt;::allocateBytes(sizeof(T)*(<a class="el" href="glext_8h.html#a619bc20e8198de3bd3f3d7fc34de66b2">count</a>)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a block of memory for a primitive type aligned to user defined boundaries, and indicate the category of usage. </p>

</div>
</div>
<a id="ga728b719dd1425d46a78fe87d6f9ea6a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga728b719dd1425d46a78fe87d6f9ea6a5">&#9670;&nbsp;</a></span>OGRE_ALLOC_T_SIMD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OGRE_ALLOC_T_SIMD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="glext_8h.html#a619bc20e8198de3bd3f3d7fc34de66b2">count</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">category&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;static_cast&lt;T*&gt;(::<a class="el" href="class_ogre_1_1_categorised_align_alloc_policy.html">Ogre::CategorisedAlignAllocPolicy</a>&lt;category&gt;::allocateBytes(sizeof(T)*(<a class="el" href="glext_8h.html#a619bc20e8198de3bd3f3d7fc34de66b2">count</a>)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a block of memory for a primitive type aligned to SIMD boundaries, and indicate the category of usage. </p>

</div>
</div>
<a id="gad18eff671a00617b21c8e35a7f545690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad18eff671a00617b21c8e35a7f545690">&#9670;&nbsp;</a></span>OGRE_DELETE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OGRE_DELETE&#160;&#160;&#160;delete</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gab9f9fa14d424036dc5881cbcb3c741e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9f9fa14d424036dc5881cbcb3c741e0">&#9670;&nbsp;</a></span>OGRE_DELETE_ARRAY_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OGRE_DELETE_ARRAY_T</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="glext_8h.html#a619bc20e8198de3bd3f3d7fc34de66b2">count</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">category&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;if(ptr){for (<a class="el" href="_s_d_l__config_8h.html#a7c94ea6f8948649f8d181ae55911eeaf">size_t</a> <a class="el" href="glext_8h.html#a0f71581a41fd2264c8944126dabbd010">b</a> = 0; <a class="el" href="glext_8h.html#a0f71581a41fd2264c8944126dabbd010">b</a> &lt; <a class="el" href="glext_8h.html#a619bc20e8198de3bd3f3d7fc34de66b2">count</a>; ++<a class="el" href="glext_8h.html#a0f71581a41fd2264c8944126dabbd010">b</a>) { (ptr)[<a class="el" href="glext_8h.html#a0f71581a41fd2264c8944126dabbd010">b</a>].~T();} ::<a class="el" href="class_ogre_1_1_categorised_alloc_policy.html">Ogre::CategorisedAllocPolicy</a>&lt;category&gt;::deallocateBytes((<a class="el" href="_s_d_l__opengles2__gl2ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>*)ptr);}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the memory allocated with OGRE_NEW_ARRAY_T. Category is required to be restated to ensure the matching policy is used, count and type to call destructor. </p>

</div>
</div>
<a id="ga25e1e9ce907fc367cc735465c940da23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25e1e9ce907fc367cc735465c940da23">&#9670;&nbsp;</a></span>OGRE_DELETE_ARRAY_T_ALIGN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OGRE_DELETE_ARRAY_T_ALIGN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="glext_8h.html#a619bc20e8198de3bd3f3d7fc34de66b2">count</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">category, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">align&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;if(ptr){for (<a class="el" href="_s_d_l__config_8h.html#a7c94ea6f8948649f8d181ae55911eeaf">size_t</a> _b = 0; _b &lt; <a class="el" href="glext_8h.html#a619bc20e8198de3bd3f3d7fc34de66b2">count</a>; ++_b) { (ptr)[_b].~T();} ::<a class="el" href="class_ogre_1_1_categorised_align_alloc_policy.html">Ogre::CategorisedAlignAllocPolicy</a>&lt;category, align&gt;::deallocateBytes((<a class="el" href="_s_d_l__opengles2__gl2ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>*)ptr);}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the memory allocated with OGRE_NEW_ARRAY_T_ALIGN. Category is required to be restated to ensure the matching policy is used, count and type to call destructor. </p>

</div>
</div>
<a id="ga3ceedc1e74432821ffab664232c12d04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ceedc1e74432821ffab664232c12d04">&#9670;&nbsp;</a></span>OGRE_DELETE_ARRAY_T_SIMD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OGRE_DELETE_ARRAY_T_SIMD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="glext_8h.html#a619bc20e8198de3bd3f3d7fc34de66b2">count</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">category&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;if(ptr){for (<a class="el" href="_s_d_l__config_8h.html#a7c94ea6f8948649f8d181ae55911eeaf">size_t</a> <a class="el" href="glext_8h.html#a0f71581a41fd2264c8944126dabbd010">b</a> = 0; <a class="el" href="glext_8h.html#a0f71581a41fd2264c8944126dabbd010">b</a> &lt; <a class="el" href="glext_8h.html#a619bc20e8198de3bd3f3d7fc34de66b2">count</a>; ++<a class="el" href="glext_8h.html#a0f71581a41fd2264c8944126dabbd010">b</a>) { (ptr)[<a class="el" href="glext_8h.html#a0f71581a41fd2264c8944126dabbd010">b</a>].~T();} ::<a class="el" href="class_ogre_1_1_categorised_align_alloc_policy.html">Ogre::CategorisedAlignAllocPolicy</a>&lt;category&gt;::deallocateBytes((<a class="el" href="_s_d_l__opengles2__gl2ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>*)ptr);}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the memory allocated with OGRE_NEW_ARRAY_T_SIMD. Category is required to be restated to ensure the matching policy is used, count and type to call destructor. </p>

</div>
</div>
<a id="ga0b0974da65362dd8a14071e7f6e4daca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b0974da65362dd8a14071e7f6e4daca">&#9670;&nbsp;</a></span>OGRE_DELETE_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OGRE_DELETE_T</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">category&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;if(ptr){(ptr)-&gt;~T(); ::<a class="el" href="class_ogre_1_1_categorised_alloc_policy.html">Ogre::CategorisedAllocPolicy</a>&lt;category&gt;::deallocateBytes((<a class="el" href="_s_d_l__opengles2__gl2ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>*)ptr);}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the memory allocated with OGRE_NEW_T. Category is required to be restated to ensure the matching policy is used. </p>

</div>
</div>
<a id="ga076af127ea8efe2284e03ab4c2057603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga076af127ea8efe2284e03ab4c2057603">&#9670;&nbsp;</a></span>OGRE_DELETE_T_ALIGN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OGRE_DELETE_T_ALIGN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">category, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">align&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;if(ptr){(ptr)-&gt;~T(); ::<a class="el" href="class_ogre_1_1_categorised_align_alloc_policy.html">Ogre::CategorisedAlignAllocPolicy</a>&lt;category, align&gt;::deallocateBytes((<a class="el" href="_s_d_l__opengles2__gl2ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>*)ptr);}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the memory allocated with OGRE_NEW_T_ALIGN. Category is required to be restated to ensure the matching policy is used. </p>

</div>
</div>
<a id="ga1a5d598e538371f2fca9608277051347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a5d598e538371f2fca9608277051347">&#9670;&nbsp;</a></span>OGRE_DELETE_T_SIMD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OGRE_DELETE_T_SIMD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">category&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;if(ptr){(ptr)-&gt;~T(); ::<a class="el" href="class_ogre_1_1_categorised_align_alloc_policy.html">Ogre::CategorisedAlignAllocPolicy</a>&lt;category&gt;::deallocateBytes((<a class="el" href="_s_d_l__opengles2__gl2ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>*)ptr);}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the memory allocated with OGRE_NEW_T_SIMD. Category is required to be restated to ensure the matching policy is used. </p>

</div>
</div>
<a id="gacfd8dc937cf390c7bff05495f0dc10cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacfd8dc937cf390c7bff05495f0dc10cf">&#9670;&nbsp;</a></span>OGRE_FREE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OGRE_FREE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">category&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;::<a class="el" href="class_ogre_1_1_categorised_alloc_policy.html">Ogre::CategorisedAllocPolicy</a>&lt;category&gt;::deallocateBytes((<a class="el" href="_s_d_l__opengles2__gl2ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>*)ptr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the memory allocated with OGRE_MALLOC or OGRE_ALLOC_T. Category is required to be restated to ensure the matching policy is used. </p>

</div>
</div>
<a id="gaa06d37a211e3da357b8457ccdb4decac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa06d37a211e3da357b8457ccdb4decac">&#9670;&nbsp;</a></span>OGRE_FREE_ALIGN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OGRE_FREE_ALIGN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">category, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">align&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;::<a class="el" href="class_ogre_1_1_categorised_align_alloc_policy.html">Ogre::CategorisedAlignAllocPolicy</a>&lt;category, align&gt;::deallocateBytes((<a class="el" href="_s_d_l__opengles2__gl2ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>*)ptr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the memory allocated with either OGRE_MALLOC_ALIGN or OGRE_ALLOC_T_ALIGN. Category is required to be restated to ensure the matching policy is used. </p>

</div>
</div>
<a id="gaf7501eb098fc6671420c628dc80af2a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7501eb098fc6671420c628dc80af2a8">&#9670;&nbsp;</a></span>OGRE_FREE_SIMD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OGRE_FREE_SIMD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">category&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;::<a class="el" href="class_ogre_1_1_categorised_align_alloc_policy.html">Ogre::CategorisedAlignAllocPolicy</a>&lt;category&gt;::deallocateBytes((<a class="el" href="_s_d_l__opengles2__gl2ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>*)ptr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the memory allocated with either OGRE_MALLOC_SIMD or OGRE_ALLOC_T_SIMD. Category is required to be restated to ensure the matching policy is used. </p>

</div>
</div>
<a id="ga2382b731c3d757f74f0fedf2b14ed9d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2382b731c3d757f74f0fedf2b14ed9d6">&#9670;&nbsp;</a></span>OGRE_MALLOC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OGRE_MALLOC</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bytes, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">category&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;::<a class="el" href="class_ogre_1_1_categorised_alloc_policy.html">Ogre::CategorisedAllocPolicy</a>&lt;category&gt;::allocateBytes(bytes)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a block of raw memory, and indicate the category of usage. </p>

</div>
</div>
<a id="ga876cf0a4c7e209ce798b5e6708ca2343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga876cf0a4c7e209ce798b5e6708ca2343">&#9670;&nbsp;</a></span>OGRE_MALLOC_ALIGN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OGRE_MALLOC_ALIGN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bytes, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">category, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">align&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;::<a class="el" href="class_ogre_1_1_categorised_align_alloc_policy.html">Ogre::CategorisedAlignAllocPolicy</a>&lt;category, align&gt;::allocateBytes(bytes)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a block of raw memory aligned to user defined boundaries, and indicate the category of usage. </p>

</div>
</div>
<a id="gafd7ddaef10ac9ea1ffbd18902167b9a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd7ddaef10ac9ea1ffbd18902167b9a2">&#9670;&nbsp;</a></span>OGRE_MALLOC_SIMD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OGRE_MALLOC_SIMD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bytes, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">category&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;::<a class="el" href="class_ogre_1_1_categorised_align_alloc_policy.html">Ogre::CategorisedAlignAllocPolicy</a>&lt;category&gt;::allocateBytes(bytes)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a block of raw memory aligned to SIMD boundaries, and indicate the category of usage. </p>

</div>
</div>
<a id="gab5fc1358fd5a889de0a06d07e45df1ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5fc1358fd5a889de0a06d07e45df1ff">&#9670;&nbsp;</a></span>OGRE_NEW</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OGRE_NEW&#160;&#160;&#160;new</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga6c428bbdad197df6a4ba22d3c1d48f5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c428bbdad197df6a4ba22d3c1d48f5a">&#9670;&nbsp;</a></span>OGRE_NEW_ARRAY_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OGRE_NEW_ARRAY_T</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="glext_8h.html#a619bc20e8198de3bd3f3d7fc34de66b2">count</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">category&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;::<a class="el" href="group___memory.html#gae542663b49eb68a74336d84e11ba0b9c">Ogre::constructN</a>(static_cast&lt;T*&gt;(::<a class="el" href="class_ogre_1_1_categorised_alloc_policy.html">Ogre::CategorisedAllocPolicy</a>&lt;category&gt;::allocateBytes(sizeof(T)*(<a class="el" href="glext_8h.html#a619bc20e8198de3bd3f3d7fc34de66b2">count</a>))), <a class="el" href="glext_8h.html#a619bc20e8198de3bd3f3d7fc34de66b2">count</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a block of memory for 'count' primitive types - do not use for classes that inherit from AllocatedObject. </p>

</div>
</div>
<a id="ga51224b5c8af6fd85e192975ebe20139b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51224b5c8af6fd85e192975ebe20139b">&#9670;&nbsp;</a></span>OGRE_NEW_ARRAY_T_ALIGN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OGRE_NEW_ARRAY_T_ALIGN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="glext_8h.html#a619bc20e8198de3bd3f3d7fc34de66b2">count</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">category, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">align&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;::<a class="el" href="group___memory.html#gae542663b49eb68a74336d84e11ba0b9c">Ogre::constructN</a>(static_cast&lt;T*&gt;(::<a class="el" href="class_ogre_1_1_categorised_align_alloc_policy.html">Ogre::CategorisedAlignAllocPolicy</a>&lt;category, align&gt;::allocateBytes(sizeof(T)*(<a class="el" href="glext_8h.html#a619bc20e8198de3bd3f3d7fc34de66b2">count</a>))), <a class="el" href="glext_8h.html#a619bc20e8198de3bd3f3d7fc34de66b2">count</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a block of memory for 'count' primitive types aligned to user defined boundaries - do not use for classes that inherit from AllocatedObject. </p>

</div>
</div>
<a id="gaa55846bae98cf66fd5158ad0d4d623bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa55846bae98cf66fd5158ad0d4d623bb">&#9670;&nbsp;</a></span>OGRE_NEW_ARRAY_T_SIMD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OGRE_NEW_ARRAY_T_SIMD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="glext_8h.html#a619bc20e8198de3bd3f3d7fc34de66b2">count</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">category&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;::<a class="el" href="group___memory.html#gae542663b49eb68a74336d84e11ba0b9c">Ogre::constructN</a>(static_cast&lt;T*&gt;(::<a class="el" href="class_ogre_1_1_categorised_align_alloc_policy.html">Ogre::CategorisedAlignAllocPolicy</a>&lt;category&gt;::allocateBytes(sizeof(T)*(<a class="el" href="glext_8h.html#a619bc20e8198de3bd3f3d7fc34de66b2">count</a>))), <a class="el" href="glext_8h.html#a619bc20e8198de3bd3f3d7fc34de66b2">count</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a block of memory for 'count' primitive types aligned to SIMD boundaries - do not use for classes that inherit from AllocatedObject. </p>

</div>
</div>
<a id="ga46253f12658ce0922e982a8a9dd11312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46253f12658ce0922e982a8a9dd11312">&#9670;&nbsp;</a></span>OGRE_NEW_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OGRE_NEW_T</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">category&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;new (::<a class="el" href="class_ogre_1_1_categorised_alloc_policy.html">Ogre::CategorisedAllocPolicy</a>&lt;category&gt;::allocateBytes(sizeof(T))) T</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate space for one primitive type, external type or non-virtual type with constructor parameters. </p>

</div>
</div>
<a id="ga4c928813aac2c96ae5cc775aacd3e26d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c928813aac2c96ae5cc775aacd3e26d">&#9670;&nbsp;</a></span>OGRE_NEW_T_ALIGN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OGRE_NEW_T_ALIGN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">category, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">align&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;new (::<a class="el" href="class_ogre_1_1_categorised_align_alloc_policy.html">Ogre::CategorisedAlignAllocPolicy</a>&lt;category, align&gt;::allocateBytes(sizeof(T))) T</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate space for one primitive type, external type or non-virtual type aligned to user defined boundaries. </p>

</div>
</div>
<a id="ga2f7eef98b7fe3ba9f36630b787d603b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f7eef98b7fe3ba9f36630b787d603b1">&#9670;&nbsp;</a></span>OGRE_NEW_T_SIMD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OGRE_NEW_T_SIMD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">category&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;new (::<a class="el" href="class_ogre_1_1_categorised_align_alloc_policy.html">Ogre::CategorisedAlignAllocPolicy</a>&lt;category&gt;::allocateBytes(sizeof(T))) T</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate space for one primitive type, external type or non-virtual type aligned to SIMD boundaries. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga830fab51be174d6f2849857cb1abb36a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga830fab51be174d6f2849857cb1abb36a">&#9670;&nbsp;</a></span>MemoryCategory</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___memory.html#ga830fab51be174d6f2849857cb1abb36a">Ogre::MemoryCategory</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A set of categories that indicate the purpose of a chunk of memory being allocated. These categories will be provided at allocation time in order to allow the allocation policy to vary its behaviour if it wishes. This allows you to use a single policy but still have variant behaviour. The level of control it gives you is at a higher level than assigning different policies to different classes, but is the only control you have over general allocations that are primitive types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga830fab51be174d6f2849857cb1abb36aa8ac29a2852b1b5fe79d1659b16f521cb"></a>MEMCATEGORY_GENERAL&#160;</td><td class="fielddoc"><p>General purpose. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga830fab51be174d6f2849857cb1abb36aaf9e04ff475de4493bc942a9c73da4c2e"></a>MEMCATEGORY_GEOMETRY&#160;</td><td class="fielddoc"><p>Geometry held in main memory. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga830fab51be174d6f2849857cb1abb36aa24267bedbd1115a8f208e4ee355693e4"></a>MEMCATEGORY_ANIMATION&#160;</td><td class="fielddoc"><p><a class="el" href="class_ogre_1_1_animation.html">Animation</a> data like tracks, bone matrices. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga830fab51be174d6f2849857cb1abb36aa8a55fa0fcaa8403bb51ca210f882ed90"></a>MEMCATEGORY_SCENE_CONTROL&#160;</td><td class="fielddoc"><p>Nodes, control data. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga830fab51be174d6f2849857cb1abb36aaffe1e3d51d961175f8f2756611439181"></a>MEMCATEGORY_SCENE_OBJECTS&#160;</td><td class="fielddoc"><p>Scene object instances. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga830fab51be174d6f2849857cb1abb36aa04bad2e7f64cc2b6f4cda9f56b59e5b4"></a>MEMCATEGORY_RESOURCE&#160;</td><td class="fielddoc"><p>Other resources. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga830fab51be174d6f2849857cb1abb36aaa037d2f843117cd5fb39ec064d7ff23b"></a>MEMCATEGORY_SCRIPTING&#160;</td><td class="fielddoc"><p>Scripting. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga830fab51be174d6f2849857cb1abb36aa29274489311d683a88676dbb1c779788"></a>MEMCATEGORY_RENDERSYS&#160;</td><td class="fielddoc"><p>Rendersystem structures. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga830fab51be174d6f2849857cb1abb36aa4ff2b9446477e2ea4170b09d8aaa1b67"></a>MEMCATEGORY_COUNT&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gae542663b49eb68a74336d84e11ba0b9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae542663b49eb68a74336d84e11ba0b9c">&#9670;&nbsp;</a></span>constructN()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* Ogre::constructN </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>basePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_s_d_l__config_8h.html#a7c94ea6f8948649f8d181ae55911eeaf">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Utility function for constructing an array of objects with placement new, without using new[] (which allocates an undocumented amount of extra memory and so isn't appropriate for custom allocators). </p>

</div>
</div>
<a id="ga34a9308dc656f694883718bf8fa4f1c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34a9308dc656f694883718bf8fa4f1c2">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T2 , typename P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_s_t_l_allocator.html">STLAllocator</a>&lt; T, P &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_s_t_l_allocator.html">STLAllocator</a>&lt; T2, P &gt; const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>determine equality, can memory from another allocator be released by this allocator, (ISO C++) </p>

</div>
</div>
<a id="ga0cec9339a4ab3eaf48c767087cd7f400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0cec9339a4ab3eaf48c767087cd7f400">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename OtherAllocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_s_t_l_allocator.html">STLAllocator</a>&lt; T, P &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OtherAllocator const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>determine equality, can memory from another allocator be released by this allocator, (ISO C++) </p>

</div>
</div>
<a id="gaa5b83b2ba3ce965e3d8dd129c93ee43b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5b83b2ba3ce965e3d8dd129c93ee43b">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T2 , typename P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_s_t_l_allocator.html">STLAllocator</a>&lt; T, P &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_s_t_l_allocator.html">STLAllocator</a>&lt; T2, P &gt; const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>determine equality, can memory from another allocator be released by this allocator, (ISO C++) </p>

</div>
</div>
<a id="gaa34a630f2287087875d360c454a0fb48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa34a630f2287087875d360c454a0fb48">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename OtherAllocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_s_t_l_allocator.html">STLAllocator</a>&lt; T, P &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OtherAllocator const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>determine equality, can memory from another allocator be released by this allocator, (ISO C++) </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
